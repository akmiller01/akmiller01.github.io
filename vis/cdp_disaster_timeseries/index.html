<!DOCTYPE html>
<head>
<meta charset="utf-8">
<style>
    .area {
        fill: #353672;
        clip-path: url(#clip);
    }
    .point {
        fill: #353672;
        stroke: white;
        stroke-width: 1.5;
    }

    .line {
        fill: none;
        stroke: #353672;
        stroke-width: 2px;
        }

    .event-rect {
        fill: #ff3c0f;
        fill-opacity: 0.8;
    }

    .zoom {
        cursor: move;
        fill: none;
        pointer-events: all;
    }

    .tooltip {
            position: absolute;
            text-align: left;
            padding: 5px;
            background: lightsteelblue;
            border: 1px solid gray;
            border-radius: 5px;
            white-space: preserve nowrap;
        }
</style>
</head>
<body>
<label for="country">Country:</label>
<select id="country"></select>
<label for="indicator">Indicator:</label>
<select id="indicator"></select>
<label for="disaster">Disasters:</label>
<select id="disaster"></select>
<div id="chart">
    <svg width="960" height="500"></svg>
</div>
</body>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>

function setUrlParam(key, value){
    // Get the current URLSearchParams object
    const queryParams = new URLSearchParams(window.location.search);

    // Set a new parameter or modify an existing one
    queryParams.set(key, value);

    // Construct the new URL
    const newUrl = window.location.pathname + '?' + queryParams.toString();

    // Update the URL in the browser history without reloading the page
    history.replaceState(null, null, newUrl);
}

function getUrlParam(key){
    // Get the current URLSearchParams object
    const queryParams = new URLSearchParams(window.location.search);
    return(queryParams.get(key))
}

var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 110, left: 100},
    margin2 = {top: 430, right: 20, bottom: 30, left: 100},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom,
    height2 = +svg.attr("height") - margin2.top - margin2.bottom;

var parseDate = d3.timeParse("%Y-%m-%d");

var x = d3.scaleTime().range([0, width]),
    x2 = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    y2 = d3.scaleLinear().range([height2, 0]);

var xAxis = d3.axisBottom(x),
    xAxis2 = d3.axisBottom(x2),
    yAxis = d3.axisLeft(y);

var line = d3.line()
    .x(d => x(d.date))
    .y(d => y(d.value));

var area2 = d3.area()
    .curve(d3.curveMonotoneX)
    .x(function(d) { return x2(d.date); })
    .y0(height2)
    .y1(function(d) { return y2(d.value); });

var brush = d3.brushX()
    .extent([[0, 0], [width, height2]])
    .on("brush end", brushed);

var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .on("zoom", zoomed);

svg.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

    // Draw zoom area
svg.append("rect")
    .attr("class", "zoom")
    .attr("width", width)
    .attr("height", height)
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .call(zoom);

var focus = svg.append("g")
    .attr("class", "focus")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .call(zoom);

var context = svg.append("g")
    .attr("class", "context")
    .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

// Tooltip
const tooltip = d3.select("body")
    .append("div")
    .attr("class", "tooltip")
    .style("display", "none")
    .on('mouseover', function(d, i) {
        tooltip.transition().duration(0);  // on mouse over cancel mouse out transition
        tooltip.style("display", "block");
    })
    .on('mouseout', function(d, i) {
        tooltip.style("display", "none");  // on mouseout hide tip
    });

d3.csv("data.csv", type).then(function(all_data) {
  // Load initial data
  const countries = [...new Set(all_data.map(d => d.country_name))].filter(d => d !== "").sort();
  let selectedCountry = countries[0];
  if(getUrlParam('c') !== null){
    selectedCountry = getUrlParam('c');
  }else{
    setUrlParam('c', selectedCountry);
  }
  let all_country_data = all_data.filter((d) => d.country_name==selectedCountry)
  let indicator_types = [...new Set(all_country_data.map(d => d.indicator_type_name))].filter(d => d !== "").sort();
  let selectedIndicator = indicator_types[0];
  if(getUrlParam('i') !== null){
    selectedIndicator = getUrlParam('i');
  }else{
    setUrlParam('i', selectedIndicator);
  }
  let disaster_types = [...new Set(all_country_data.map(d => d.disaster_types_name))].filter(d => d !== "").sort();
  let selectedDisaster = disaster_types[0];
  if(getUrlParam('d') !== null){
    selectedDisaster = getUrlParam('d');
  }else{
    setUrlParam('d', selectedDisaster);
  }

  function updateDropdowns() {
    d3.selectAll("#country").selectAll("option")
        .data(countries)
        .join("option")
        .attr("value", d => d)
        .text(d => d);

    d3.select("#country").property('value', selectedCountry);

    all_country_data = all_data.filter((d) => d.country_name==selectedCountry)
    indicator_types = [...new Set(all_country_data.map(d => d.indicator_type_name))].filter(d => d !== "").sort();
    if(!indicator_types.includes(selectedIndicator)){
        selectedIndicator = indicator_types[0];
    };
    disaster_types = [...new Set(all_country_data.map(d => d.disaster_types_name))].filter(d => d !== "").sort();
    if(!disaster_types.includes(selectedDisaster)){
        selectedDisaster = disaster_types[0];
    }

    d3.select("#indicator").selectAll("option")
        .data(indicator_types)
        .join("option")
        .attr("value", d => d)
        .text(d => d);

    d3.select("#indicator").property('value', selectedIndicator);

    d3.select("#disaster").selectAll("option")
        .data(disaster_types)
        .join("option")
        .attr("value", d => d)
        .text(d => d);

    d3.select("#disaster").property('value', selectedDisaster);
  };
  

  function drawChart() {
    country_data = all_data.filter((d) => d.country_name==selectedCountry && (d.indicator_type_name==selectedIndicator || d.disaster_types_name === selectedDisaster));
    data = country_data.filter((d) => d.indicator_type_name==selectedIndicator);
    event_data = country_data.filter((d) => d.disaster_types_name === selectedDisaster);

    // Set domains
    var xExtent = d3.extent(country_data, function(d) { return d.date; }),
    xRange = Date.parse(xExtent[1]) - Date.parse(xExtent[0]);
    x.domain([Date.parse(xExtent[0]) - (xRange * .01), Date.parse(xExtent[1]) + (xRange * .01)]);
    var yMax =  d3.max(data, function(d) { return d.value; });
    y.domain([0, yMax * 1.05]);
    x2.domain(x.domain());
    y2.domain(y.domain());

    // Draw event rectangles
    focus.selectAll(".event-rect").remove();
    focus.selectAll(".event-rect")
        .data(event_data)
        .enter().append("rect")
        .attr("class", "event-rect")
        .attr("clip-path", "url(#clip)")
        .attr("x", d => x(d.date))
        .attr("y", 0)
        .attr("height", height)
        .attr("width", (d) => {
            var w_start = x(d.date),
            w_end = x(Date.parse(d.date) + (1000 * 60 * 60 * 23)),
            rect_width = Math.max(w_end - w_start, 2);
            return(rect_width);
        })
        .on("mouseover", function(event, d) {
            tooltip.transition().duration(0); // cancel any pending transition
            tooltip.style("display", "block");
            tooltip.html(d.tooltip_html)
                .style("left", (event.pageX + 5) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
            tooltip.transition().delay(500).style("display", "none");
        });
    // Draw focus line
    var line = d3.line()
        .x(d => x(d.date))
        .y(d => y(d.value));
    focus.selectAll('.line').remove();
    focus.append("path")
        .datum(data)
        .attr("class", "line")
        .attr("clip-path", "url(#clip)")
        .attr("d", line);
    //Draw mouseover points
    focus.selectAll(".point").remove();
    focus.selectAll(".point")
        .data(data)
        .enter().append("circle")
        .attr("class", "point")
        .attr("clip-path", "url(#clip)")
        .attr("cx", d => x(d.date))
        .attr("cy", d => y(d.value))
        .attr("r", 4)
        .on("mouseover", function(event, d) {
            tooltip.transition().duration(200).style("display", "block");
            tooltip.html(d.tooltip_html)
                .style("left", (event.pageX + 5) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
            tooltip.transition().duration(500).style("display", "none");
        });

    // Draw focus axes
    focus.selectAll(".axis").remove();
    focus.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);
    focus.append("g")
        .attr("class", "axis axis--y")
        .call(yAxis);

    // Draw context area
    var area2 = d3.area()
        .curve(d3.curveMonotoneX)
        .x(function(d) { return x2(d.date); })
        .y0(height2)
        .y1(function(d) { return y2(d.value); });
    context.selectAll('.area').remove();
    context.append("path")
        .datum(data)
        .attr("class", "area")
        .attr("d", area2);
    context.selectAll(".axis").remove();
    context.append("g")
        .attr("class", "axis axis--x")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);
    context.selectAll(".brush").remove();
    context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range());
  };

    // Update chart based on dropdown selection
    d3.select("#country").on("change", function() {
        selectedCountry = this.value;
        setUrlParam('c', selectedCountry);
        updateDropdowns();
        drawChart();
    });

    d3.select("#indicator").on("change", function() {
        selectedIndicator = this.value;
        setUrlParam('i', selectedIndicator);
        drawChart();
    });

    d3.select("#disaster").on("change", function() {
        selectedDisaster = this.value;
        setUrlParam('d', selectedDisaster);
        drawChart();
    });

    // Initialize
    updateDropdowns();
    drawChart();
});

function brushed(event, d) {
  if (event.sourceEvent === undefined) return; // ignore brush-by-zoom
  var s = event.selection || x2.range();
  x.domain(s.map(x2.invert, x2));
  focus.select(".line").attr("d", line);
  svg.selectAll(".point").attr("cx", d => x(d.date)).attr("cy", d => y(d.value));
  svg.selectAll(".event-rect").attr("x", d => x(d.date))
    .attr("width", (d) => {
        var w_start = x(d.date),
        w_end = x(Date.parse(d.date) + (1000 * 60 * 60 * 23)),
        rect_width = Math.max(w_end - w_start, 2);
        return(rect_width);
    });
  focus.select(".axis--x").call(xAxis);
  svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
      .scale(width / (s[1] - s[0]))
      .translate(-s[0], 0));
}

function zoomed(event, d) {
  if (event.sourceEvent === undefined) return; // ignore zoom-by-brush
  var t = event.transform;
  x.domain(t.rescaleX(x2).domain());
  focus.select(".line").attr("d", line);
  svg.selectAll(".point").attr("cx", d => x(d.date)).attr("cy", d => y(d.value));
  svg.selectAll(".event-rect").attr("x", d => x(d.date))
    .attr("width", (d) => {
        var w_start = x(d.date),
        w_end = x(Date.parse(d.date) + (1000 * 60 * 60 * 23)),
        rect_width = Math.max(w_end - w_start, 2);
        return(rect_width);
    });
  focus.select(".axis--x").call(xAxis);
  context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
}

function type(d) {
  d.date = parseDate(d.date);
  d.value = parseFloat(d.value);
  return d;
}

</script>